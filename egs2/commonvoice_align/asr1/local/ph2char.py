import argparse
import os
from pathlib import Path
from utils import read_anchor_file


def ph2char(anchor_file, hyp_file, ref_file, output, eps):
    """
    Replace the aligned phoneme anchor file generated by wer_per_utt_details.pl with the original char text.
    """
    # print(read_anchor_file(anchor_file, return_uttid=True))
    uttid, ref_ph, hyp_ph, op, csid = read_anchor_file(anchor_file, return_uttid=True)
    with open(hyp_file, "r") as f:
        hyp_uttid, hyp_chars = f.read().strip().split(" ", maxsplit=1)
        hyp_chars = hyp_chars.split(" ")
    assert hyp_uttid == uttid
    with open(ref_file, "r") as f:
        ref_uttid, ref_chars = f.read().strip().split(" ", maxsplit=1)
        ref_chars = ref_chars.split(" ")
    assert ref_uttid == uttid

    with open(output, "w") as f:
        ref_result = [f"{uttid} ref"]
        hyp_result = [f"{uttid} hyp"]
        op_result = [f"{uttid} op"]
        op_result.extend(op)

        ref_counter = 0
        for phoneme in ref_ph:
            if phoneme != eps:
                ref_result.append(ref_chars[ref_counter])
                ref_counter += 1
            else:
                ref_result.append(eps)

        hyp_counter = 0
        for phoneme in hyp_ph:
            if phoneme != eps:
                hyp_result.append(hyp_chars[hyp_counter])
                hyp_counter += 1
            else:
                hyp_result.append(eps)

        assert len(hyp_result) == len(ref_result)

        print(" ".join(ref_result), file=f)
        print(" ".join(hyp_result), file=f)
        print(" ".join(op_result), file=f)
        csid = " ".join(csid)
        print(f"{uttid} #csid {csid}", file=f)


def main():
    parser = argparse.ArgumentParser(
        description='Determine anchor utterances based on the aligned text file.')
    parser.add_argument('--anchor_file', type=Path, required=True,
                        help='The full path to the anchor file storing the alignment info')
    parser.add_argument('--hyp_file', type=Path, required=True,
                        help='The full path to the file in which the merged decoded text is stored')
    parser.add_argument('--ref_file', type=Path, required=True,
                        help='The full path to the file in which the merged reference text is stored')
    parser.add_argument('--output', type=Path, required=True,
                        help='The full path to the file in which the char anchor result will stored')
    parser.add_argument('--eps', type=str, default="<eps>",
                        help="The special epsilon token in the anchor text")
    args = parser.parse_args()

    ph2char(anchor_file=args.anchor_file, hyp_file=args.hyp_file,
            ref_file=args.ref_file, output=args.output, eps=args.eps)


if __name__ == "__main__":
    main()
